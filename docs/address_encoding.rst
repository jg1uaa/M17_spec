アドレスのエンコード
====================

M17 は 48 ビット (6 バイト) 長のアドレスを使用する。コールサイン (および
その他のアドレス) は以下の方法で 6 バイトにエンコードされる:

*  アドレス 0 は無効

.. todo:: アドレス 0 は何かのフラグとして使えないか？

* アドレス 1 〜 262143999999999 (すなわち :math:`40^9-1`) は、
  最大 9 文字のテキストを以下に示す base40 形式でエンコードしたもの
* アドレス 262144000000000 (:math:`40^9`) 〜
  281474976710654 (:math:`2^{48}-2`) は無効

.. todo:: この 19330976710655 個のアドレスの扱いはどうする？

* アドレス 0xFFFFFFFFFFFF はブロードキャスト用、
  全ての局はこのアドレスを待ち受け、受信しなければならない

.. table:: アドレスの割り当て

   +------------------------------+---------------+-------------------+-------------------+
   |アドレス範囲                  |種別           |アドレス個数       |備考               |
   +==============================+===============+===================+===================+
   |0x000000000000                |予約           |1                  |将来の拡張用       |
   +------------------------------+---------------+-------------------+-------------------+
   |0x000000000001-0xee6b27ffffff |ユニット ID    |262143999999999    |                   |
   +------------------------------+---------------+-------------------+-------------------+
   |0xee6b28000000-0xfffffffffffe |予約           |19330976710655     |将来の拡張用       |
   +------------------------------+---------------+-------------------+-------------------+
   |0xffffffffffff                |ブロードキャ   |1                  |宛先の指定にのみ   |
   |                              |スト           |                   |使用可能           |
   +------------------------------+---------------+-------------------+-------------------+

コールサインのエンコード: base40
--------------------------------

使用可能な 40 種の文字 9 文字を 48bit、6 バイトにエンコードする。
base40 で使用する文字は以下の通り:

* 0: 1 個の空白 (スペース)、不正な文字は全てこの文字に置き換えられる
* 1-26: "A" 〜 "Z"
* 27-36: "0" 〜 "9"
* 37: "-" (ハイフン)
* 38: "/" (スラッシュ)
* 39: "." (ドット/ピリオド)

エンコードはリトルエンディアンで行う。すなわち、エンコード元となる文字列の右端の文字は
エンコード結果の最上位ビット側に配置される。


コード例: encode_base40()
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c

   uint64_t encode_callsign_base40(const char *callsign) {
     uint64_t encoded = 0;
     for (const char *p = (callsign + strlen(callsign) - 1); p >= callsign; p-- ) {
       encoded *= 40;
       // コードサイズよりも速度を重視する場合、256 バイトのテーブルを使っても良い
       if (*p >= 'A' && *p <= 'Z') // 1-26
         encoded += *p - 'A' + 1;
       else if (*p >= '0' && *p <= '9') // 27-36
         encoded += *p - '0' + 27;
       else if (*p == '-') // 37
         encoded += 37;
       // ここはプレースホルダー、他の文字に変更する場合はここを修正する
       // デコード側の修正も忘れずに
       else if (*p == '/') // 38
         encoded += 38;
       else if (*p == '.') // 39
         encoded += 39;
       else
         // 不正な文字やスペースは 0 とする、スペースとしてデコードされる
         //encoded += 0;
     }
     return encoded;
   }

コード例: decode_base40()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: c

   char *decode_callsign_base40(uint64_t encoded, char *callsign) {
     if (encoded >= 262144000000000) { // 40^9
       *callsign = 0;
       return callsign;
     }
     char *p = callsign;
     for (; encoded > 0; p++) {
       *p = " ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-/."[encoded % 40];
       encoded /= 40;
     }
     *p = 0;

     return callsign;
   }

base40 採用の理由
~~~~~~~~~~~~~~~~~

FCC によって割り当てられる一般的なコールサインにおいて、もっとも長いものは 6 文字である。
アメリカのコールサインを構成するに必要とされる、A-Z, 0-9 そして "done" character (XXXこれ何？) では
:math:`log2(37^6)=31.26` ビットないし 4 バイトとなる。

いくつかの国ではこれより長いコールサインを使い、米国においてもしばしばイベントで
長いコールサインが発行される。これに加え、ユーザもコールサインを拡張 (後述) したい時がある。
故に 6 文字以上は必要とされる。より多くの文字数を使う場合、どれくらいのビット数が必要になるだろうか:

.. list-table:: 文字数とビット数
   :header-rows: 1

   * - 文字数
     - ビット数
     - バイト数
   * - 7
     - :math:`log2(37^7)=36.47`
     - 5
   * - 8
     - :math:`log2(37^8)=41.67`
     - 6
   * - 9
     - :math:`log2(37^9)=46.89`
     - 6
   * - 10
     - :math:`log2(37^{10})=52.09`
     - 7

これらから、9 文字を 6 バイトで表現するのが良い落としどころになりそうだ。
それでは 9 個の文字を 6 バイトを超えない範囲で表現する際に、どれくらいの文字種を
使うことができるだろうか？

.. list-table:: alphabet size vs bytes
   :header-rows: 1

   * - 文字種
     - ビット数
     - バイト数
   * - 37
     - :math:`log2(37^9)=46.89`
     - 6
   * - 38
     - :math:`log2(38^9)=47.23`
     - 6
   * - 39
     - :math:`log2(39^9)=47.57`
     - 6
   * - 40
     - :math:`log2(40^9)=47.90`
     - 6
   * - 41
     - :math:`log2(41^9)=48.22`
     - 7

結果として、40 種のアルファベット 9 文字が 6 バイトを最大限に使うことができる。

コールサインのフォーマット
--------------------------

主官庁の発行したコールサインを、手を加えること無くそのままエンコードできること。

複数局の扱い
~~~~~~~~~~~~

同一の運用者が複数局を扱えるようにするため、AX.25 における '-' の文字と
SSID フィールドの概念を借用する。例えばコールサイン "KR6ZY-1" は "KR6ZY-2" や
"KR6ZY" と異なる局を示すが、全て運用者は "KR6ZY" に所属する。

一時修飾子 (Temporary Modifiers)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

似たようなものとして、たとえば移動局における "KR6ZY/M" や Amateur Extra 級の操作権限を
持っているが FCC データベースの更新がまだ行われていない状態を示す "KR6ZY/AE"
(訳者注: KR6ZY は Advanced 級のコールサインである) のような、一時的なステータスの変化を
示すサフィックスがコールサインに付加される場合がある。そのために '/' は base40 の
文字に含まれている。'-' と '/' との違いは、'-' は異なる局として認識されるが、
'/' については**そうではない**。これらのサフィックスは同一の局に対する一時的な修飾として
解釈される。

.. todo:: これが実際にどのような影響を及ぼすかは不明である

相互運用性
~~~~~~~~~~

M17 と他のネットワーク間において、情報を橋渡しできることが望ましい。
base40 エンコードされた 9 文字が可能なこととしては:

.. todo:: その他のシステムに対する相互運用性についての記載、System Fusion, P25, IRLP, AllStar など？

DMR
+++

残念なことに、DMR は名前空間における単一性が保証されていない。
個々の ID は https://www.radioid.net/database/search#! においてよく管理されているが、
トークグループについてはそうであるとは言い難い。BrandMeister におけるトークグループ
XYZ とプライベートな cBridge システムにおけるトークグループ XYZ はおそらく
(そしてしばしば) 異なったものとなっている。

* DMR ID は D<数字> のようにエンコードする 例: D3106728 → KR6ZY
* DMR トークグループはネットワーク毎にエンコードする、現時点において
  以下のネットワークについて定義する:
* Brandmeister: BM<数字> 例: BM31075
* DMRPlus: DP<数字> 例: DP262
* 今後さらに追加される可能性あり

D-Star
++++++

D-Star リフレクタの名称は適切に定義されている: REFxxxY これはそのまま base40 にエンコードできる。

.. todo:: Individuals?(XXX) 単にコールサインだけ？

相互運用を行う際における技術的な挑戦事項
++++++++++++++++++++++++++++++++++++++++

発信元の ID を他のネットワークに対し通知する必要がある。相互運用を行う
それぞれのネットワークにおいてユニークな形で、これをどう実現するかに
ついてはまだ決まっていない。おそらく DMR/BM ゲートウェイに関しては
DMR データベースからコールサインを自動的に検索し DMR ID に割り付ければ
良いのだろうか？さらなる検討が必要だ。

CODEC2 は他のネットワークが使う形式 (大半が AMBE もしくはそれに類するもの) に
トランスコードする必要がある。それによりどのような音になるのかは気になるところである。
